{"ast":null,"code":"var lineBottomCommand=function lineBottomCommand(point){return\"L \".concat(point[0],\" \").concat(point[3]);};var lineUpperCommand=function lineUpperCommand(point){return\"L \".concat(point[0],\" \").concat(point[4]);};// const svgCommand = point => `L ${point[0]} ${point[2]}`\nvar svgPath=function svgPath(points,command,color,dash){var d=points.reduce(function(acc,point,i,a){return i===0?\"M \".concat(point[0],\",\").concat(point[2]):\"\".concat(acc,\" \").concat(bezierCommand(point,i,a));},'');return\"<path d=\\\"\".concat(d,\"\\\" fill=\\\"none\\\" stroke=\").concat(color,\" stroke-width=2  data-z-index=\\\"0\\\" stroke-dasharray=\").concat(dash,\" pointer-events=\\\"none\\\" />\");};// stroke-dasharray=\"4\"\nvar areaPath=function areaPath(points,command,color){var d1=points.reduce(function(acc,point,i,a){return i===0?\"M \".concat(point[0],\",\").concat(point[4]):\"\".concat(acc,\" \").concat(bezierCommand_upper(point,i,a));},'');d1+=\" L \".concat(points[points.length-1][0],\" \").concat(points[points.length-1][3],\"  \");var d3=points.reverse().reduce(function(acc,point,i,a){return i===0?\"L \".concat(point[0],\",\").concat(point[3]):\"\".concat(acc,\" \").concat(bezierCommand_lower(point,i,a));},'');d3+=\" L \".concat(points[points.length-1][0],\" \").concat(points[points.length-1][4],\"  \");var d=d1+d3;//////////////////////////////////////////\nreturn\"<path d=\\\"\".concat(d,\"\\\" fill=\").concat(color,\" stroke=\").concat(color,\" stroke-width=2 data-z-index=\\\"0\\\" pointer-events=\\\"none\\\" opacity=\\\"0.35\\\" />\");};var lineCommand=function lineCommand(point){return\"L \".concat(point[0],\" \").concat(point[2]);};console.log(\"data\");export function area_path(data,color){var dash=arguments.length>2&&arguments[2]!==undefined?arguments[2]:0;var result=[];result.push(svgPath(data,lineCommand,color,dash));result.push(areaPath(data,bezierCommand,color));return result;}// export function area_path_future(data, color, dash=0){\n//   let result = [];\n//   // console.log(data)\n//   result.push(svgPath(data, lineCommand, color, 4 ));\n//   result.push(areaPath(data, bezierCommand, color));\n//   return result;\n// }\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// The smoothing ratio\nvar smoothing=0.2;// Properties of a line \n// I:  - pointA (array) [x,y]: coordinates\n//     - pointB (array) [x,y]: coordinates\n// O:  - (object) { length: l, angle: a }: properties of the line\nvar line=function line(pointA,pointB){var lengthX=pointB[0]-pointA[0];var lengthY=pointB[2]-pointA[2];return{length:Math.sqrt(Math.pow(lengthX,2)+Math.pow(lengthY,2)),angle:Math.atan2(lengthY,lengthX)};};// Position of a control point \n// I:  - current (array) [x, y]: current point coordinates\n//     - previous (array) [x, y]: previous point coordinates\n//     - next (array) [x, y]: next point coordinates\n//     - reverse (boolean, optional): sets the direction\n// O:  - (array) [x,y]: a tuple of coordinates\nvar controlPoint=function controlPoint(current,previous,next,reverse){// When 'current' is the first or last point of the array\n// 'previous' or 'next' don't exist.\n// Replace with 'current'\nvar p=previous||current;var n=next||current;// Properties of the opposed-line\nvar o=line(p,n);// If is end-control-point, add PI to the angle to go backward\nvar angle=o.angle+(reverse?Math.PI:0);var length=o.length*smoothing;// The control point position is relative to the current point\nvar x=current[0]+Math.cos(angle)*length;var y=current[2]+Math.sin(angle)*length;return[x,y];};// Create the bezier curve command \n// I:  - point (array) [x,y]: current point coordinates\n//     - i (integer): index of 'point' in the array 'a'\n//     - a (array): complete array of points coordinates\n// O:  - (string) 'C x2,y2 x1,y1 x,y': SVG cubic bezier C command\nvar bezierCommand=function bezierCommand(point,i,a){// start control point\nvar cps=controlPoint(a[i-1],a[i-2],point);// end control point\nvar cpe=controlPoint(point,a[i-1],a[i+1],true);return\"C \".concat(cps[0],\",\").concat(cps[1],\" \").concat(cpe[0],\",\").concat(cpe[1],\" \").concat(point[0],\",\").concat(point[2]);};var bezierCommand_upper=function bezierCommand_upper(point,i,a){// start control point\nvar cps=controlPoint_upper(a[i-1],a[i-2],point);// end control point\nvar cpe=controlPoint_upper(point,a[i-1],a[i+1],true);return\"C \".concat(cps[0],\",\").concat(cps[1],\" \").concat(cpe[0],\",\").concat(cpe[1],\" \").concat(point[0],\",\").concat(point[4]);};var bezierCommand_lower=function bezierCommand_lower(point,i,a){// start control point\nvar cps=controlPoint_lower(a[i-1],a[i-2],point);// end control point\nvar cpe=controlPoint_lower(point,a[i-1],a[i+1],true);return\"C \".concat(cps[0],\",\").concat(cps[1],\" \").concat(cpe[0],\",\").concat(cpe[1],\" \").concat(point[0],\",\").concat(point[3]);};var line_lower=function line_lower(pointA,pointB){var lengthX=pointB[0]-pointA[0];var lengthY=pointB[3]-pointA[3];return{length:Math.sqrt(Math.pow(lengthX,2)+Math.pow(lengthY,2)),angle:Math.atan2(lengthY,lengthX)};};var line_upper=function line_upper(pointA,pointB){var lengthX=pointB[0]-pointA[0];var lengthY=pointB[4]-pointA[4];return{length:Math.sqrt(Math.pow(lengthX,2)+Math.pow(lengthY,2)),angle:Math.atan2(lengthY,lengthX)};};var controlPoint_lower=function controlPoint_lower(current,previous,next,reverse){// When 'current' is the first or last point of the array\n// 'previous' or 'next' don't exist.\n// Replace with 'current'\nvar p=previous||current;var n=next||current;// Properties of the opposed-line\nvar o=line_lower(p,n);// If is end-control-point, add PI to the angle to go backward\nvar angle=o.angle+(reverse?Math.PI:0);var length=o.length*smoothing;// The control point position is relative to the current point\nvar x=current[0]+Math.cos(angle)*length;var y=current[3]+Math.sin(angle)*length;return[x,y];};var controlPoint_upper=function controlPoint_upper(current,previous,next,reverse){// When 'current' is the first or last point of the array\n// 'previous' or 'next' don't exist.\n// Replace with 'current'\nvar p=previous||current;var n=next||current;// Properties of the opposed-line\nvar o=line_upper(p,n);// If is end-control-point, add PI to the angle to go backward\nvar angle=o.angle+(reverse?Math.PI:0);var length=o.length*smoothing;// The control point position is relative to the current point\nvar x=current[0]+Math.cos(angle)*length;var y=current[4]+Math.sin(angle)*length;return[x,y];};","map":{"version":3,"sources":["/Users/marcin/workspace/react/flask-react-app/client/src/utils_dates/area_path.js"],"names":["lineBottomCommand","point","lineUpperCommand","svgPath","points","command","color","dash","d","reduce","acc","i","a","bezierCommand","areaPath","d1","bezierCommand_upper","length","d3","reverse","bezierCommand_lower","lineCommand","console","log","area_path","data","result","push","smoothing","line","pointA","pointB","lengthX","lengthY","Math","sqrt","pow","angle","atan2","controlPoint","current","previous","next","p","n","o","PI","x","cos","y","sin","cps","cpe","controlPoint_upper","controlPoint_lower","line_lower","line_upper"],"mappings":"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","sourcesContent":["      \nconst lineBottomCommand = point => `L ${point[0]} ${point[3]}`\n\nconst lineUpperCommand = point => `L ${point[0]} ${point[4]}`\n\n// const svgCommand = point => `L ${point[0]} ${point[2]}`\n\n\nconst svgPath = (points, command, color, dash) => {\n\n  const d = points.reduce((acc, point, i, a) => i === 0\n  ? `M ${point[0]},${point[2]}`\n  : `${acc} ${bezierCommand(point, i, a)}`\n  , '')\n\n  return `<path d=\"${d}\" fill=\"none\" stroke=${color} stroke-width=2  data-z-index=\"0\" stroke-dasharray=${dash} pointer-events=\"none\" />`\n}\n// stroke-dasharray=\"4\"\n\nconst areaPath = (points, command, color) => {\n\n  let d1 = points.reduce((acc, point, i, a) => i === 0\n  ? `M ${point[0]},${point[4]}`\n  : `${acc} ${bezierCommand_upper(point, i, a)}`\n  , '');\n\n\n\n  d1 += ` L ${points[points.length - 1][0]} ${points[points.length - 1][3]}  `;\n\n  let d3 = points.reverse().reduce((acc, point, i, a) => i === 0\n  ? `L ${point[0]},${point[3]}`\n  : `${acc} ${bezierCommand_lower(point, i, a)}`\n  , '');\n\n\n  d3 += ` L ${points[points.length - 1][0]} ${points[points.length - 1][4]}  `;\n\n  let d = d1 + d3;\n//////////////////////////////////////////\n\n  return `<path d=\"${d}\" fill=${color} stroke=${color} stroke-width=2 data-z-index=\"0\" pointer-events=\"none\" opacity=\"0.35\" />`\n}\n\n\n\nconst lineCommand = point => `L ${point[0]} ${point[2]}`\nconsole.log(\"data\")\n\n\n    \nexport function area_path(data, color, dash=0){\n\n    let result = [];\n    result.push(svgPath(data, lineCommand, color, dash));\n    result.push(areaPath(data, bezierCommand, color));\n\n    return result;\n}\n\n// export function area_path_future(data, color, dash=0){\n\n//   let result = [];\n\n//   // console.log(data)\n//   result.push(svgPath(data, lineCommand, color, 4 ));\n//   result.push(areaPath(data, bezierCommand, color));\n\n//   return result;\n// }\n\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// The smoothing ratio\nconst smoothing = 0.2\n\n\n// Properties of a line \n// I:  - pointA (array) [x,y]: coordinates\n//     - pointB (array) [x,y]: coordinates\n// O:  - (object) { length: l, angle: a }: properties of the line\nconst line = (pointA, pointB) => {\n  const lengthX = pointB[0] - pointA[0]\n  const lengthY = pointB[2] - pointA[2]\n  return {\n    length: Math.sqrt(Math.pow(lengthX, 2) + Math.pow(lengthY, 2)),\n    angle: Math.atan2(lengthY, lengthX)\n  }\n}\n\n// Position of a control point \n// I:  - current (array) [x, y]: current point coordinates\n//     - previous (array) [x, y]: previous point coordinates\n//     - next (array) [x, y]: next point coordinates\n//     - reverse (boolean, optional): sets the direction\n// O:  - (array) [x,y]: a tuple of coordinates\nconst controlPoint = (current, previous, next, reverse) => {\n\n  // When 'current' is the first or last point of the array\n  // 'previous' or 'next' don't exist.\n  // Replace with 'current'\n  const p = previous || current\n  const n = next || current\n\n  // Properties of the opposed-line\n  const o = line(p, n)\n\n  // If is end-control-point, add PI to the angle to go backward\n  const angle = o.angle + (reverse ? Math.PI : 0)\n  const length = o.length * smoothing\n\n  // The control point position is relative to the current point\n  const x = current[0] + Math.cos(angle) * length\n  const y = current[2] + Math.sin(angle) * length\n  return [x, y]\n}\n\n// Create the bezier curve command \n// I:  - point (array) [x,y]: current point coordinates\n//     - i (integer): index of 'point' in the array 'a'\n//     - a (array): complete array of points coordinates\n// O:  - (string) 'C x2,y2 x1,y1 x,y': SVG cubic bezier C command\nconst bezierCommand = (point, i, a) => {\n\n  // start control point\n  const cps = controlPoint(a[i - 1], a[i - 2], point)\n\n  // end control point\n  const cpe = controlPoint(point, a[i - 1], a[i + 1], true)\n  return `C ${cps[0]},${cps[1]} ${cpe[0]},${cpe[1]} ${point[0]},${point[2]}`\n}\n\n\nconst bezierCommand_upper = (point, i, a) => {\n\n  // start control point\n  const cps = controlPoint_upper(a[i - 1], a[i - 2], point)\n\n  // end control point\n  const cpe = controlPoint_upper(point, a[i - 1], a[i + 1], true)\n  return `C ${cps[0]},${cps[1]} ${cpe[0]},${cpe[1]} ${point[0]},${point[4]}`\n}\n\nconst bezierCommand_lower = (point, i, a) => {\n\n  // start control point\n  const cps = controlPoint_lower(a[i - 1], a[i - 2], point)\n\n  // end control point\n  const cpe = controlPoint_lower(point, a[i - 1], a[i + 1], true)\n  return `C ${cps[0]},${cps[1]} ${cpe[0]},${cpe[1]} ${point[0]},${point[3]}`\n}\n\n\nconst line_lower = (pointA, pointB) => {\n  const lengthX = pointB[0] - pointA[0]\n  const lengthY = pointB[3] - pointA[3]\n  return {\n    length: Math.sqrt(Math.pow(lengthX, 2) + Math.pow(lengthY, 2)),\n    angle: Math.atan2(lengthY, lengthX)\n  }\n}\n\nconst line_upper = (pointA, pointB) => {\n  const lengthX = pointB[0] - pointA[0]\n  const lengthY = pointB[4] - pointA[4]\n  return {\n    length: Math.sqrt(Math.pow(lengthX, 2) + Math.pow(lengthY, 2)),\n    angle: Math.atan2(lengthY, lengthX)\n  }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst controlPoint_lower = (current, previous, next, reverse) => {\n\n  // When 'current' is the first or last point of the array\n  // 'previous' or 'next' don't exist.\n  // Replace with 'current'\n  const p = previous || current\n  const n = next || current\n\n  // Properties of the opposed-line\n  const o = line_lower(p, n)\n\n  // If is end-control-point, add PI to the angle to go backward\n  const angle = o.angle + (reverse ? Math.PI : 0)\n  const length = o.length * smoothing\n\n  // The control point position is relative to the current point\n  const x = current[0] + Math.cos(angle) * length\n  const y = current[3] + Math.sin(angle) * length\n  return [x, y]\n}\n\nconst controlPoint_upper = (current, previous, next, reverse) => {\n\n  // When 'current' is the first or last point of the array\n  // 'previous' or 'next' don't exist.\n  // Replace with 'current'\n  const p = previous || current\n  const n = next || current\n\n  // Properties of the opposed-line\n  const o = line_upper(p, n)\n\n  // If is end-control-point, add PI to the angle to go backward\n  const angle = o.angle + (reverse ? Math.PI : 0)\n  const length = o.length * smoothing\n\n  // The control point position is relative to the current point\n  const x = current[0] + Math.cos(angle) * length\n  const y = current[4] + Math.sin(angle) * length\n  return [x, y]\n}"]},"metadata":{},"sourceType":"module"}