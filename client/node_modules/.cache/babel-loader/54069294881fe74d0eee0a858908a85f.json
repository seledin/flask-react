{"ast":null,"code":"const lineBottomCommand = point => `L ${point[0]} ${point[3]}`;\n\nconst lineUpperCommand = point => `L ${point[0]} ${point[4]}`; // const svgCommand = point => `L ${point[0]} ${point[2]}`\n\n\nconst svgPath = (points, command, color, dash) => {\n  const d = points.reduce((acc, point, i, a) => i === 0 ? `M ${point[0]},${point[2]}` : `${acc} ${bezierCommand(point, i, a)}`, '');\n  return `<path d=\"${d}\" fill=\"none\" stroke=${color} stroke-width=2  data-z-index=\"0\" stroke-dasharray=${dash} pointer-events=\"none\" />`;\n}; // stroke-dasharray=\"4\"\n\n\nconst areaPath = (points, command, color) => {\n  let d1 = points.reduce((acc, point, i, a) => i === 0 ? `M ${point[0]},${point[4]}` : `${acc} ${bezierCommand_upper(point, i, a)}`, '');\n  d1 += ` L ${points[points.length - 1][0]} ${points[points.length - 1][3]}  `;\n  let d3 = points.reverse().reduce((acc, point, i, a) => i === 0 ? `L ${point[0]},${point[3]}` : `${acc} ${bezierCommand_lower(point, i, a)}`, '');\n  d3 += ` L ${points[points.length - 1][0]} ${points[points.length - 1][4]}  `;\n  let d = d1 + d3; //////////////////////////////////////////\n\n  return `<path d=\"${d}\" fill=${color} stroke=${color} stroke-width=2 data-z-index=\"0\" pointer-events=\"none\" opacity=\"0.35\" />`;\n};\n\nconst lineCommand = point => `L ${point[0]} ${point[2]}`;\n\nexport function area_path(data, color, dash = 0, slice = 0) {\n  let result = [];\n  result.push(svgPath(data, lineCommand, color, dash));\n  result.push(areaPath(data.slice(slice), bezierCommand, color));\n  return result;\n} // export function area_path_future(data, color, dash=0){\n//   let result = [];\n//   // console.log(data)\n//   result.push(svgPath(data, lineCommand, color, 4 ));\n//   result.push(areaPath(data, bezierCommand, color));\n//   return result;\n// }\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// The smoothing ratio\n\nconst smoothing = 0.2; // Properties of a line \n// I:  - pointA (array) [x,y]: coordinates\n//     - pointB (array) [x,y]: coordinates\n// O:  - (object) { length: l, angle: a }: properties of the line\n\nconst line = (pointA, pointB) => {\n  const lengthX = pointB[0] - pointA[0];\n  const lengthY = pointB[2] - pointA[2];\n  return {\n    length: Math.sqrt(Math.pow(lengthX, 2) + Math.pow(lengthY, 2)),\n    angle: Math.atan2(lengthY, lengthX)\n  };\n}; // Position of a control point \n// I:  - current (array) [x, y]: current point coordinates\n//     - previous (array) [x, y]: previous point coordinates\n//     - next (array) [x, y]: next point coordinates\n//     - reverse (boolean, optional): sets the direction\n// O:  - (array) [x,y]: a tuple of coordinates\n\n\nconst controlPoint = (current, previous, next, reverse) => {\n  // When 'current' is the first or last point of the array\n  // 'previous' or 'next' don't exist.\n  // Replace with 'current'\n  const p = previous || current;\n  const n = next || current; // Properties of the opposed-line\n\n  const o = line(p, n); // If is end-control-point, add PI to the angle to go backward\n\n  const angle = o.angle + (reverse ? Math.PI : 0);\n  const length = o.length * smoothing; // The control point position is relative to the current point\n\n  const x = current[0] + Math.cos(angle) * length;\n  const y = current[2] + Math.sin(angle) * length;\n  return [x, y];\n}; // Create the bezier curve command \n// I:  - point (array) [x,y]: current point coordinates\n//     - i (integer): index of 'point' in the array 'a'\n//     - a (array): complete array of points coordinates\n// O:  - (string) 'C x2,y2 x1,y1 x,y': SVG cubic bezier C command\n\n\nconst bezierCommand = (point, i, a) => {\n  // start control point\n  const cps = controlPoint(a[i - 1], a[i - 2], point); // end control point\n\n  const cpe = controlPoint(point, a[i - 1], a[i + 1], true);\n  return `C ${cps[0]},${cps[1]} ${cpe[0]},${cpe[1]} ${point[0]},${point[2]}`;\n};\n\nconst bezierCommand_upper = (point, i, a) => {\n  // start control point\n  const cps = controlPoint_upper(a[i - 1], a[i - 2], point);\n\n  if (point[4] < 0) {\n    console.log(point[0] + \": \" + point[1] + \" : \" + point[4]);\n  } // end control point\n\n\n  const cpe = controlPoint_upper(point, a[i - 1], a[i + 1], true);\n  return `C ${cps[0]},${cps[1]} ${cpe[0]},${cpe[1]} ${point[0]},${point[4]}`;\n};\n\nconst bezierCommand_lower = (point, i, a) => {\n  // start control point\n  const cps = controlPoint_lower(a[i - 1], a[i - 2], point); // end control point\n\n  const cpe = controlPoint_lower(point, a[i - 1], a[i + 1], true);\n  return `C ${cps[0]},${cps[1]} ${cpe[0]},${cpe[1]} ${point[0]},${point[3]}`;\n};\n\nconst line_lower = (pointA, pointB) => {\n  const lengthX = pointB[0] - pointA[0];\n  const lengthY = pointB[3] - pointA[3];\n  return {\n    length: Math.sqrt(Math.pow(lengthX, 2) + Math.pow(lengthY, 2)),\n    angle: Math.atan2(lengthY, lengthX)\n  };\n};\n\nconst line_upper = (pointA, pointB) => {\n  const lengthX = pointB[0] - pointA[0];\n  const lengthY = pointB[4] - pointA[4];\n  return {\n    length: Math.sqrt(Math.pow(lengthX, 2) + Math.pow(lengthY, 2)),\n    angle: Math.atan2(lengthY, lengthX)\n  };\n};\n\nconst controlPoint_lower = (current, previous, next, reverse) => {\n  // When 'current' is the first or last point of the array\n  // 'previous' or 'next' don't exist.\n  // Replace with 'current'\n  const p = previous || current;\n  const n = next || current; // Properties of the opposed-line\n\n  const o = line_lower(p, n); // If is end-control-point, add PI to the angle to go backward\n\n  const angle = o.angle + (reverse ? Math.PI : 0);\n  const length = o.length * smoothing; // The control point position is relative to the current point\n\n  const x = current[0] + Math.cos(angle) * length;\n  const y = current[3] + Math.sin(angle) * length;\n  return [x, y];\n};\n\nconst controlPoint_upper = (current, previous, next, reverse) => {\n  // When 'current' is the first or last point of the array\n  // 'previous' or 'next' don't exist.\n  // Replace with 'current'\n  const p = previous || current;\n  const n = next || current; // Properties of the opposed-line\n\n  const o = line_upper(p, n); // If is end-control-point, add PI to the angle to go backward\n\n  const angle = o.angle + (reverse ? Math.PI : 0);\n  const length = o.length * smoothing; // The control point position is relative to the current point\n\n  const x = current[0] + Math.cos(angle) * length;\n  const y = current[4] + Math.sin(angle) * length;\n  return [x, y];\n};","map":{"version":3,"sources":["/Users/marcin/workspace/react/flask-react-app/client/src/utils_dates/area_path.js"],"names":["lineBottomCommand","point","lineUpperCommand","svgPath","points","command","color","dash","d","reduce","acc","i","a","bezierCommand","areaPath","d1","bezierCommand_upper","length","d3","reverse","bezierCommand_lower","lineCommand","area_path","data","slice","result","push","smoothing","line","pointA","pointB","lengthX","lengthY","Math","sqrt","pow","angle","atan2","controlPoint","current","previous","next","p","n","o","PI","x","cos","y","sin","cps","cpe","controlPoint_upper","console","log","controlPoint_lower","line_lower","line_upper"],"mappings":"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","sourcesContent":["      \nconst lineBottomCommand = point => `L ${point[0]} ${point[3]}`\n\nconst lineUpperCommand = point => `L ${point[0]} ${point[4]}`\n\n// const svgCommand = point => `L ${point[0]} ${point[2]}`\n\n\nconst svgPath = (points, command, color, dash) => {\n\n  const d = points.reduce((acc, point, i, a) => i === 0\n  ? `M ${point[0]},${point[2]}`\n  : `${acc} ${bezierCommand(point, i, a)}`\n  , '')\n\n  return `<path d=\"${d}\" fill=\"none\" stroke=${color} stroke-width=2  data-z-index=\"0\" stroke-dasharray=${dash} pointer-events=\"none\" />`\n}\n// stroke-dasharray=\"4\"\n\nconst areaPath = (points, command, color) => {\n\n  let d1 = points.reduce((acc, point, i, a) => i === 0\n  ? `M ${point[0]},${point[4]}`\n  : `${acc} ${bezierCommand_upper(point, i, a)}`\n  , '');\n\n\n\n  d1 += ` L ${points[points.length - 1][0]} ${points[points.length - 1][3]}  `;\n\n  let d3 = points.reverse().reduce((acc, point, i, a) => i === 0\n  ? `L ${point[0]},${point[3]}`\n  : `${acc} ${bezierCommand_lower(point, i, a)}`\n  , '');\n\n\n  d3 += ` L ${points[points.length - 1][0]} ${points[points.length - 1][4]}  `;\n\n  let d = d1 + d3;\n//////////////////////////////////////////\n\n  return `<path d=\"${d}\" fill=${color} stroke=${color} stroke-width=2 data-z-index=\"0\" pointer-events=\"none\" opacity=\"0.35\" />`\n}\n\n\n\nconst lineCommand = point => `L ${point[0]} ${point[2]}`\n\n    \nexport function area_path(data, color, dash=0, slice=0){\n\n\n    let result = [];\n    result.push(svgPath(data, lineCommand, color, dash));\n    result.push(areaPath(data.slice(slice), bezierCommand, color));\n\n    return result;\n}\n\n// export function area_path_future(data, color, dash=0){\n\n//   let result = [];\n\n//   // console.log(data)\n//   result.push(svgPath(data, lineCommand, color, 4 ));\n//   result.push(areaPath(data, bezierCommand, color));\n\n//   return result;\n// }\n\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// The smoothing ratio\nconst smoothing = 0.2\n\n\n// Properties of a line \n// I:  - pointA (array) [x,y]: coordinates\n//     - pointB (array) [x,y]: coordinates\n// O:  - (object) { length: l, angle: a }: properties of the line\nconst line = (pointA, pointB) => {\n  const lengthX = pointB[0] - pointA[0]\n  const lengthY = pointB[2] - pointA[2]\n  return {\n    length: Math.sqrt(Math.pow(lengthX, 2) + Math.pow(lengthY, 2)),\n    angle: Math.atan2(lengthY, lengthX)\n  }\n}\n\n// Position of a control point \n// I:  - current (array) [x, y]: current point coordinates\n//     - previous (array) [x, y]: previous point coordinates\n//     - next (array) [x, y]: next point coordinates\n//     - reverse (boolean, optional): sets the direction\n// O:  - (array) [x,y]: a tuple of coordinates\nconst controlPoint = (current, previous, next, reverse) => {\n\n  // When 'current' is the first or last point of the array\n  // 'previous' or 'next' don't exist.\n  // Replace with 'current'\n  const p = previous || current\n  const n = next || current\n\n  // Properties of the opposed-line\n  const o = line(p, n)\n\n  // If is end-control-point, add PI to the angle to go backward\n  const angle = o.angle + (reverse ? Math.PI : 0)\n  const length = o.length * smoothing\n\n  // The control point position is relative to the current point\n  const x = current[0] + Math.cos(angle) * length\n  const y = current[2] + Math.sin(angle) * length\n  return [x, y]\n}\n\n// Create the bezier curve command \n// I:  - point (array) [x,y]: current point coordinates\n//     - i (integer): index of 'point' in the array 'a'\n//     - a (array): complete array of points coordinates\n// O:  - (string) 'C x2,y2 x1,y1 x,y': SVG cubic bezier C command\nconst bezierCommand = (point, i, a) => {\n\n  // start control point\n  const cps = controlPoint(a[i - 1], a[i - 2], point)\n\n  // end control point\n  const cpe = controlPoint(point, a[i - 1], a[i + 1], true)\n  return `C ${cps[0]},${cps[1]} ${cpe[0]},${cpe[1]} ${point[0]},${point[2]}`\n}\n\n\nconst bezierCommand_upper = (point, i, a) => {\n\n  // start control point\n  const cps = controlPoint_upper(a[i - 1], a[i - 2], point)\n\n  if(point[4]<0){\n    console.log(point[0]+ \": \" +point[1] + \" : \" + point[4])\n  }\n  // end control point\n  const cpe = controlPoint_upper(point, a[i - 1], a[i + 1], true)\n  return `C ${cps[0]},${cps[1]} ${cpe[0]},${cpe[1]} ${point[0]},${point[4]}`\n}\n\nconst bezierCommand_lower = (point, i, a) => {\n\n  // start control point\n  const cps = controlPoint_lower(a[i - 1], a[i - 2], point)\n\n  // end control point\n  const cpe = controlPoint_lower(point, a[i - 1], a[i + 1], true)\n  return `C ${cps[0]},${cps[1]} ${cpe[0]},${cpe[1]} ${point[0]},${point[3]}`\n}\n\n\nconst line_lower = (pointA, pointB) => {\n  const lengthX = pointB[0] - pointA[0]\n  const lengthY = pointB[3] - pointA[3]\n  return {\n    length: Math.sqrt(Math.pow(lengthX, 2) + Math.pow(lengthY, 2)),\n    angle: Math.atan2(lengthY, lengthX)\n  }\n}\n\nconst line_upper = (pointA, pointB) => {\n  const lengthX = pointB[0] - pointA[0]\n  const lengthY = pointB[4] - pointA[4]\n  return {\n    length: Math.sqrt(Math.pow(lengthX, 2) + Math.pow(lengthY, 2)),\n    angle: Math.atan2(lengthY, lengthX)\n  }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst controlPoint_lower = (current, previous, next, reverse) => {\n\n  // When 'current' is the first or last point of the array\n  // 'previous' or 'next' don't exist.\n  // Replace with 'current'\n  const p = previous || current\n  const n = next || current\n\n  // Properties of the opposed-line\n  const o = line_lower(p, n)\n\n  // If is end-control-point, add PI to the angle to go backward\n  const angle = o.angle + (reverse ? Math.PI : 0)\n  const length = o.length * smoothing\n\n  // The control point position is relative to the current point\n  const x = current[0] + Math.cos(angle) * length\n  const y = current[3] + Math.sin(angle) * length\n  return [x, y]\n}\n\nconst controlPoint_upper = (current, previous, next, reverse) => {\n\n  // When 'current' is the first or last point of the array\n  // 'previous' or 'next' don't exist.\n  // Replace with 'current'\n  const p = previous || current\n  const n = next || current\n\n  // Properties of the opposed-line\n  const o = line_upper(p, n)\n\n  // If is end-control-point, add PI to the angle to go backward\n  const angle = o.angle + (reverse ? Math.PI : 0)\n  const length = o.length * smoothing\n\n  // The control point position is relative to the current point\n  const x = current[0] + Math.cos(angle) * length\n  const y = current[4] + Math.sin(angle) * length\n  return [x, y]\n}"]},"metadata":{},"sourceType":"module"}