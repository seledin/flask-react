{"ast":null,"code":"var _jsxFileName = \"/Users/marcin/workspace/react/flask-react-app/client/src/components/plot/src/plot/parts/Area_Path.js\";\nimport React from 'react';\nexport const Area_Path = props => {\n  console.log(\"path\");\n\n  if (props.style === \"dash\") {\n    return React.createElement(\"g\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 7\n      },\n      __self: this\n    }, area_path(props.data, props.color, 4));\n  } else {\n    return React.createElement(\"g\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 11\n      },\n      __self: this\n    }, area_path(props.data, props.color, 0, props.slice));\n  }\n};\nexport default Area_Path; ////////////////\n\nconst svgPath = (points, command, color, dash) => {\n  const d = points.reduce((acc, point, i, a) => i === 0 ? `M ${point[0]},${point[2]}` : `${acc} ${bezierCommand(point, i, a)}`, '');\n  return React.createElement(\"path\", {\n    d: d,\n    fill: \"none\",\n    stroke: color,\n    strokeWidth: \"2\",\n    \"data-z-index\": \"0\",\n    \"stroke-dasharray\": dash,\n    \"pointer-events\": \"none\",\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 29\n    },\n    __self: this\n  });\n};\n\nconst areaPath = (points, command, color) => {\n  let d1 = points.reduce((acc, point, i, a) => i === 0 ? `M ${point[0]},${point[4]}` : `${acc} ${bezierCommand_upper(point, i, a)}`, '');\n  d1 += ` L ${points[points.length - 1][0]} ${points[points.length - 1][3]}  `;\n  let d3 = points.reverse().reduce((acc, point, i, a) => i === 0 ? `L ${point[0]},${point[3]}` : `${acc} ${bezierCommand_lower(point, i, a)}`, '');\n  d3 += ` L ${points[points.length - 1][0]} ${points[points.length - 1][4]}  `;\n  let d = d1 + d3; //////////////////////////////////////////\n\n  return React.createElement(\"path\", {\n    d: d,\n    fill: color,\n    stroke: color,\n    \"stroke-width\": \"2\",\n    \"data-z-index\": \"0\",\n    \"pointer-events\": \"none\",\n    opacity: \"0.35\",\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 54\n    },\n    __self: this\n  });\n};\n\nconst lineCommand = point => `L ${point[0]} ${point[2]}`;\n\nexport function area_path(data, color, dash = 0, slice = 0) {\n  let result = [];\n  result.push(svgPath(data, lineCommand, color, dash));\n  result.push(areaPath(data.slice(slice), bezierCommand, color));\n  return result;\n} ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// The smoothing ratio\n\nconst smoothing = 0.2; // Properties of a line \n// I:  - pointA (array) [x,y]: coordinates\n//     - pointB (array) [x,y]: coordinates\n// O:  - (object) { length: l, angle: a }: properties of the line\n\nconst line = (pointA, pointB) => {\n  const lengthX = pointB[0] - pointA[0];\n  const lengthY = pointB[2] - pointA[2];\n  return {\n    length: Math.sqrt(Math.pow(lengthX, 2) + Math.pow(lengthY, 2)),\n    angle: Math.atan2(lengthY, lengthX)\n  };\n}; // Position of a control point \n// I:  - current (array) [x, y]: current point coordinates\n//     - previous (array) [x, y]: previous point coordinates\n//     - next (array) [x, y]: next point coordinates\n//     - reverse (boolean, optional): sets the direction\n// O:  - (array) [x,y]: a tuple of coordinates\n\n\nconst controlPoint = (current, previous, next, reverse) => {\n  // When 'current' is the first or last point of the array\n  // 'previous' or 'next' don't exist.\n  // Replace with 'current'\n  const p = previous || current;\n  const n = next || current; // Properties of the opposed-line\n\n  const o = line(p, n); // If is end-control-point, add PI to the angle to go backward\n\n  const angle = o.angle + (reverse ? Math.PI : 0);\n  const length = o.length * smoothing; // The control point position is relative to the current point\n\n  const x = current[0] + Math.cos(angle) * length;\n  const y = current[2] + Math.sin(angle) * length;\n  return [x, y];\n}; // Create the bezier curve command \n// I:  - point (array) [x,y]: current point coordinates\n//     - i (integer): index of 'point' in the array 'a'\n//     - a (array): complete array of points coordinates\n// O:  - (string) 'C x2,y2 x1,y1 x,y': SVG cubic bezier C command\n\n\nconst bezierCommand = (point, i, a) => {\n  // start control point\n  const cps = controlPoint(a[i - 1], a[i - 2], point); // end control point\n\n  const cpe = controlPoint(point, a[i - 1], a[i + 1], true);\n  return `C ${cps[0]},${cps[1]} ${cpe[0]},${cpe[1]} ${point[0]},${point[2]}`;\n};\n\nconst bezierCommand_upper = (point, i, a) => {\n  // start control point\n  const cps = controlPoint_upper(a[i - 1], a[i - 2], point); // if(point[4]<0){\n  //   console.log(point[0]+ \": \" +point[1] + \" : \" + point[4])\n  // }\n  // end control point\n\n  const cpe = controlPoint_upper(point, a[i - 1], a[i + 1], true);\n  return `C ${cps[0]},${cps[1]} ${cpe[0]},${cpe[1]} ${point[0]},${point[4]}`;\n};\n\nconst bezierCommand_lower = (point, i, a) => {\n  // start control point\n  const cps = controlPoint_lower(a[i - 1], a[i - 2], point); // end control point\n\n  const cpe = controlPoint_lower(point, a[i - 1], a[i + 1], true);\n  return `C ${cps[0]},${cps[1]} ${cpe[0]},${cpe[1]} ${point[0]},${point[3]}`;\n};\n\nconst line_lower = (pointA, pointB) => {\n  const lengthX = pointB[0] - pointA[0];\n  const lengthY = pointB[3] - pointA[3];\n  return {\n    length: Math.sqrt(Math.pow(lengthX, 2) + Math.pow(lengthY, 2)),\n    angle: Math.atan2(lengthY, lengthX)\n  };\n};\n\nconst line_upper = (pointA, pointB) => {\n  const lengthX = pointB[0] - pointA[0];\n  const lengthY = pointB[4] - pointA[4];\n  return {\n    length: Math.sqrt(Math.pow(lengthX, 2) + Math.pow(lengthY, 2)),\n    angle: Math.atan2(lengthY, lengthX)\n  };\n};\n\nconst controlPoint_lower = (current, previous, next, reverse) => {\n  // When 'current' is the first or last point of the array\n  // 'previous' or 'next' don't exist.\n  // Replace with 'current'\n  const p = previous || current;\n  const n = next || current; // Properties of the opposed-line\n\n  const o = line_lower(p, n); // If is end-control-point, add PI to the angle to go backward\n\n  const angle = o.angle + (reverse ? Math.PI : 0);\n  const length = o.length * smoothing; // The control point position is relative to the current point\n\n  const x = current[0] + Math.cos(angle) * length;\n  const y = current[3] + Math.sin(angle) * length;\n  return [x, y];\n};\n\nconst controlPoint_upper = (current, previous, next, reverse) => {\n  // When 'current' is the first or last point of the array\n  // 'previous' or 'next' don't exist.\n  // Replace with 'current'\n  const p = previous || current;\n  const n = next || current; // Properties of the opposed-line\n\n  const o = line_upper(p, n); // If is end-control-point, add PI to the angle to go backward\n\n  const angle = o.angle + (reverse ? Math.PI : 0);\n  const length = o.length * smoothing; // The control point position is relative to the current point\n\n  const x = current[0] + Math.cos(angle) * length;\n  const y = current[4] + Math.sin(angle) * length;\n  return [x, y];\n};","map":{"version":3,"sources":["/Users/marcin/workspace/react/flask-react-app/client/src/components/plot/src/plot/parts/Area_Path.js"],"names":["React","Area_Path","props","console","log","style","area_path","data","color","slice","svgPath","points","command","dash","d","reduce","acc","point","i","a","bezierCommand","areaPath","d1","bezierCommand_upper","length","d3","reverse","bezierCommand_lower","lineCommand","result","push","smoothing","line","pointA","pointB","lengthX","lengthY","Math","sqrt","pow","angle","atan2","controlPoint","current","previous","next","p","n","o","PI","x","cos","y","sin","cps","cpe","controlPoint_upper","controlPoint_lower","line_lower","line_upper"],"mappings":"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","sourcesContent":["import React from 'react';\n\nexport const Area_Path = props => {\n  console.log(\"path\")\n  if(props.style === \"dash\"){\n    return (\n      <g>{area_path(props.data, props.color, 4)}</g>\n    );\n  } else {\n    return (\n      <g>{area_path(props.data, props.color, 0, props.slice)}</g>\n    );\n  }\n};\n\nexport default Area_Path\n\n\n\n////////////////\n\nconst svgPath = (points, command, color, dash) => {\n\n  const d = points.reduce((acc, point, i, a) => i === 0\n  ? `M ${point[0]},${point[2]}`\n  : `${acc} ${bezierCommand(point, i, a)}`\n  , '')\n\n  return <path d={d} fill=\"none\" stroke={color} strokeWidth=\"2\"  data-z-index=\"0\" stroke-dasharray={dash} pointer-events=\"none\" />\n}\n\nconst areaPath = (points, command, color) => {\n\n  let d1 = points.reduce((acc, point, i, a) => i === 0\n  ? `M ${point[0]},${point[4]}`\n  : `${acc} ${bezierCommand_upper(point, i, a)}`\n  , '');\n\n\n\n  d1 += ` L ${points[points.length - 1][0]} ${points[points.length - 1][3]}  `;\n\n  let d3 = points.reverse().reduce((acc, point, i, a) => i === 0\n  ? `L ${point[0]},${point[3]}`\n  : `${acc} ${bezierCommand_lower(point, i, a)}`\n  , '');\n\n\n  d3 += ` L ${points[points.length - 1][0]} ${points[points.length - 1][4]}  `;\n\n  let d = d1 + d3;\n//////////////////////////////////////////\n\n  return <path d={d} fill={color} stroke={color} stroke-width=\"2\" data-z-index=\"0\" pointer-events=\"none\" opacity=\"0.35\" />\n}\n\n\n\nconst lineCommand = point => `L ${point[0]} ${point[2]}`\n\n    \nexport function area_path(data, color, dash=0, slice=0){\n\n\n    let result = [];\n    result.push(svgPath(data, lineCommand, color, dash));\n    result.push(areaPath(data.slice(slice), bezierCommand, color));\n\n    return result;\n}\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// The smoothing ratio\nconst smoothing = 0.2\n\n\n// Properties of a line \n// I:  - pointA (array) [x,y]: coordinates\n//     - pointB (array) [x,y]: coordinates\n// O:  - (object) { length: l, angle: a }: properties of the line\nconst line = (pointA, pointB) => {\n  const lengthX = pointB[0] - pointA[0]\n  const lengthY = pointB[2] - pointA[2]\n  return {\n    length: Math.sqrt(Math.pow(lengthX, 2) + Math.pow(lengthY, 2)),\n    angle: Math.atan2(lengthY, lengthX)\n  }\n}\n\n// Position of a control point \n// I:  - current (array) [x, y]: current point coordinates\n//     - previous (array) [x, y]: previous point coordinates\n//     - next (array) [x, y]: next point coordinates\n//     - reverse (boolean, optional): sets the direction\n// O:  - (array) [x,y]: a tuple of coordinates\nconst controlPoint = (current, previous, next, reverse) => {\n\n  // When 'current' is the first or last point of the array\n  // 'previous' or 'next' don't exist.\n  // Replace with 'current'\n  const p = previous || current\n  const n = next || current\n\n  // Properties of the opposed-line\n  const o = line(p, n)\n\n  // If is end-control-point, add PI to the angle to go backward\n  const angle = o.angle + (reverse ? Math.PI : 0)\n  const length = o.length * smoothing\n\n  // The control point position is relative to the current point\n  const x = current[0] + Math.cos(angle) * length\n  const y = current[2] + Math.sin(angle) * length\n  return [x, y]\n}\n\n// Create the bezier curve command \n// I:  - point (array) [x,y]: current point coordinates\n//     - i (integer): index of 'point' in the array 'a'\n//     - a (array): complete array of points coordinates\n// O:  - (string) 'C x2,y2 x1,y1 x,y': SVG cubic bezier C command\nconst bezierCommand = (point, i, a) => {\n\n  // start control point\n  const cps = controlPoint(a[i - 1], a[i - 2], point)\n\n  // end control point\n  const cpe = controlPoint(point, a[i - 1], a[i + 1], true)\n  return `C ${cps[0]},${cps[1]} ${cpe[0]},${cpe[1]} ${point[0]},${point[2]}`\n}\n\n\nconst bezierCommand_upper = (point, i, a) => {\n\n  // start control point\n  const cps = controlPoint_upper(a[i - 1], a[i - 2], point)\n\n  // if(point[4]<0){\n  //   console.log(point[0]+ \": \" +point[1] + \" : \" + point[4])\n  // }\n  // end control point\n  const cpe = controlPoint_upper(point, a[i - 1], a[i + 1], true)\n  return `C ${cps[0]},${cps[1]} ${cpe[0]},${cpe[1]} ${point[0]},${point[4]}`\n}\n\nconst bezierCommand_lower = (point, i, a) => {\n\n  // start control point\n  const cps = controlPoint_lower(a[i - 1], a[i - 2], point)\n\n  // end control point\n  const cpe = controlPoint_lower(point, a[i - 1], a[i + 1], true)\n  return `C ${cps[0]},${cps[1]} ${cpe[0]},${cpe[1]} ${point[0]},${point[3]}`\n}\n\n\nconst line_lower = (pointA, pointB) => {\n  const lengthX = pointB[0] - pointA[0]\n  const lengthY = pointB[3] - pointA[3]\n  return {\n    length: Math.sqrt(Math.pow(lengthX, 2) + Math.pow(lengthY, 2)),\n    angle: Math.atan2(lengthY, lengthX)\n  }\n}\n\nconst line_upper = (pointA, pointB) => {\n  const lengthX = pointB[0] - pointA[0]\n  const lengthY = pointB[4] - pointA[4]\n  return {\n    length: Math.sqrt(Math.pow(lengthX, 2) + Math.pow(lengthY, 2)),\n    angle: Math.atan2(lengthY, lengthX)\n  }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst controlPoint_lower = (current, previous, next, reverse) => {\n\n  // When 'current' is the first or last point of the array\n  // 'previous' or 'next' don't exist.\n  // Replace with 'current'\n  const p = previous || current\n  const n = next || current\n\n  // Properties of the opposed-line\n  const o = line_lower(p, n)\n\n  // If is end-control-point, add PI to the angle to go backward\n  const angle = o.angle + (reverse ? Math.PI : 0)\n  const length = o.length * smoothing\n\n  // The control point position is relative to the current point\n  const x = current[0] + Math.cos(angle) * length\n  const y = current[3] + Math.sin(angle) * length\n  return [x, y]\n}\n\nconst controlPoint_upper = (current, previous, next, reverse) => {\n\n  // When 'current' is the first or last point of the array\n  // 'previous' or 'next' don't exist.\n  // Replace with 'current'\n  const p = previous || current\n  const n = next || current\n\n  // Properties of the opposed-line\n  const o = line_upper(p, n)\n\n  // If is end-control-point, add PI to the angle to go backward\n  const angle = o.angle + (reverse ? Math.PI : 0)\n  const length = o.length * smoothing\n\n  // The control point position is relative to the current point\n  const x = current[0] + Math.cos(angle) * length\n  const y = current[4] + Math.sin(angle) * length\n  return [x, y]\n}"]},"metadata":{},"sourceType":"module"}